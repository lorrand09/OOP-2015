
-------------------------------------------------------------------
-- System Generator version 13.4 VHDL source file.
--
-- Copyright(C) 2011 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2011 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE ieee.std_logic_arith.ALL;

LIBRARY work;
USE work.timing_model_pkg.ALL;

PACKAGE timing_pkg IS

  FUNCTION get_unload_delay(C_FAMILY, C_XDEVICEFAMILY : STRING; C_ARCH, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_extra_latency_r4(C_FAMILY, C_XDEVICEFAMILY : STRING; C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_extra_latency_r2(C_FAMILY, C_XDEVICEFAMILY : STRING; C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_extra_latency_r22(C_FAMILY, C_XDEVICEFAMILY : STRING; NFFT, C_NFFT_MAX, C_BRAM_STAGES, C_HAS_SCALING, C_INPUT_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_TWIDDLE_WIDTH, C_HAS_ROUNDING : INTEGER) RETURN INTEGER;
  FUNCTION get_output_order_latency_r22(C_FAMILY, C_XDEVICEFAMILY : STRING; C_HAS_NATURAL_OUTPUT, C_OUTPUT_WIDTH, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_HAS_NFFT, C_NFFT_MAX, NFFT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_fast_bfy_latency_r22(C_NFFT_MAX, C_HAS_NFFT, C_FAST_BFY, NFFT : INTEGER) RETURN INTEGER;
  FUNCTION get_extra_latency_so(C_FAMILY, C_XDEVICEFAMILY : STRING; C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_output_order_latency_so(C_FAMILY, C_XDEVICEFAMILY : STRING; C_HAS_NATURAL_OUTPUT, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION get_run_latency(C_FAMILY, C_XDEVICEFAMILY : STRING; NFFT, C_ARCH, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_INPUT_WIDTH, C_HAS_NATURAL_OUTPUT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;
  FUNCTION gui_get_transform_latency(C_FAMILY, C_XDEVICEFAMILY : STRING; nfft, C_NFFT_MAX, C_ARCH, C_HAS_NFFT, C_INPUT_WIDTH, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_HAS_SCALING, C_HAS_BFP, C_HAS_ROUNDING, C_HAS_NATURAL_OUTPUT, C_DATA_MEM_TYPE, C_TWIDDLE_MEM_TYPE, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_FAST_CMPY, C_OPTIMIZE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER;

END timing_pkg;

PACKAGE BODY timing_pkg IS

  FUNCTION get_unload_delay(C_FAMILY, C_XDEVICEFAMILY : STRING; C_ARCH, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT ARCH_E_FUDGE_FACTOR     : INTEGER := 3;
    VARIABLE result                  : INTEGER;
  BEGIN

    CASE C_ARCH IS
      WHEN 1      =>
        result := get_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_NFFT_MAX-2, get_twiddle_latency(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX-1, C_TWIDDLE_WIDTH), 4, 4, 1, 1, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM) + 5;
      WHEN 2      =>
        result := get_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_NFFT_MAX-1, get_twiddle_latency(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX-1, C_TWIDDLE_WIDTH), 2, 2, 1, 1, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM) + 3;
      WHEN 3      =>
        result := 0;
      WHEN 4      =>
        result := get_min_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_NFFT_MAX, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM) + ARCH_E_FUDGE_FACTOR;
      WHEN OTHERS =>
        ASSERT FALSE REPORT "timing_model : get_unload_delay : unknown value of C_ARCH" SEVERITY ERROR;
    END CASE;
    RETURN result;
  END get_unload_delay;

  FUNCTION get_extra_latency_r4(C_FAMILY, C_XDEVICEFAMILY : STRING; C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT INPUT_MEMORY_DELAY : INTEGER := 3;
    CONSTANT SWITCH_DELAY       : INTEGER := 1;
    CONSTANT TWGEN_DELAY        : INTEGER := get_twiddle_latency(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX-1, C_TWIDDLE_WIDTH);
    CONSTANT DRFLY_WIDTH        : INTEGER := C_OUTPUT_WIDTH + 4;
    CONSTANT MULT_OUT_WIDTH     : INTEGER := DRFLY_WIDTH + 2;
    CONSTANT MULT_TYPE          : INTEGER := cmpy_arch(C_FAMILY, C_XDEVICEFAMILY, boolean'pos(C_FAST_CMPY = 0), max_i(C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH), min_i(C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH));
    CONSTANT MULT_DELAY         : INTEGER := mult_latency_bc(C_FAMILY, C_XDEVICEFAMILY, boolean'pos(C_FAST_CMPY = 0), C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH, MULT_OUT_WIDTH, 1, boolean'pos((MULT_TYPE /= 4) AND (MULT_TYPE /= 5)), 1, 1, 0);
    CONSTANT PE_DELAY           : INTEGER := pe_latency_b(C_FAST_BFY, MULT_DELAY, 1, C_HAS_SCALING, C_HAS_ROUNDING);
    CONSTANT MUX_DELAY          : INTEGER := 1;
    CONSTANT RW_ADDR_GEN_DELAY  : INTEGER := 4;
    CONSTANT TW_ADDR_GEN_DELAY  : INTEGER := 4;
    CONSTANT INPUT_MEM_WR_DELAY : INTEGER := INPUT_MEMORY_DELAY;
    CONSTANT MEM_DELAY          : INTEGER := get_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_NFFT_MAX-2, TWGEN_DELAY, TW_ADDR_GEN_DELAY, RW_ADDR_GEN_DELAY, MUX_DELAY, SWITCH_DELAY, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
    CONSTANT PE_PAD_DELAY       : INTEGER := (RW_ADDR_GEN_DELAY + MUX_DELAY + MEM_DELAY + SWITCH_DELAY + PE_DELAY + SWITCH_DELAY + MUX_DELAY) - (INPUT_MEM_WR_DELAY + MUX_DELAY);
  BEGIN
    RETURN PE_PAD_DELAY + 1;
  END get_extra_latency_r4;

  FUNCTION get_extra_latency_r2(C_FAMILY, C_XDEVICEFAMILY : STRING; C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT SWITCH_DELAY      : INTEGER := 1;
    CONSTANT TWGEN_DELAY       : INTEGER := get_twiddle_latency(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX-1, C_TWIDDLE_WIDTH);
    CONSTANT BTRFLY_WIDTH      : INTEGER := C_OUTPUT_WIDTH + 4;
    CONSTANT MULT_OUT_WIDTH    : INTEGER := BTRFLY_WIDTH + 2;
    CONSTANT MULT_TYPE         : INTEGER := cmpy_arch(C_FAMILY, C_XDEVICEFAMILY, boolean'pos(C_FAST_CMPY = 0), max_i(C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH), min_i(C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH));
    CONSTANT MULT_DELAY        : INTEGER := mult_latency_bc(C_FAMILY, C_XDEVICEFAMILY, boolean'pos(C_FAST_CMPY = 0), C_OUTPUT_WIDTH, C_TWIDDLE_WIDTH, MULT_OUT_WIDTH, 1, boolean'pos((MULT_TYPE /= 4) AND (MULT_TYPE /= 5)), 1, 1, 0);
    CONSTANT PE_DELAY          : INTEGER := r2_pe_latency(C_FAST_BFY, MULT_DELAY, C_HAS_SCALING, C_HAS_ROUNDING);
    CONSTANT MUX_DELAY         : INTEGER := 1;
    CONSTANT RW_ADDR_GEN_DELAY : INTEGER := 2;
    CONSTANT TW_ADDR_GEN_DELAY : INTEGER := 2;
    CONSTANT MEM_DELAY         : INTEGER := get_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_NFFT_MAX-1, TWGEN_DELAY, TW_ADDR_GEN_DELAY, RW_ADDR_GEN_DELAY, MUX_DELAY, SWITCH_DELAY, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
    CONSTANT PE_PAD_DELAY      : INTEGER := (RW_ADDR_GEN_DELAY + MUX_DELAY + MEM_DELAY + SWITCH_DELAY + PE_DELAY + 0 + MUX_DELAY) - (RW_ADDR_GEN_DELAY + MUX_DELAY);
  BEGIN
    RETURN PE_PAD_DELAY + 1;
  END get_extra_latency_r2;

  FUNCTION get_extra_latency_r22(C_FAMILY, C_XDEVICEFAMILY : STRING; NFFT, C_NFFT_MAX, C_BRAM_STAGES, C_HAS_SCALING, C_INPUT_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_TWIDDLE_WIDTH, C_HAS_ROUNDING : INTEGER) RETURN INTEGER IS
    CONSTANT NUMBER_OF_PEs    : INTEGER         := (C_NFFT_MAX+1)/2;
    CONSTANT LAST_PE_HAS_1_BF : INTEGER         := C_NFFT_MAX MOD 2;
    CONSTANT PEs_IN_USE       : INTEGER         := (NFFT+1+LAST_PE_HAS_1_BF)/2;
    CONSTANT MEM_TYPE         : r22_const_array := r22_mem_type(C_NFFT_MAX, C_BRAM_STAGES);
    CONSTANT WIDTH_OF_PE      : r22_const_array := r22_pe_width(C_HAS_SCALING, C_NFFT_MAX, C_INPUT_WIDTH);
    CONSTANT PE_LATENCIES     : r22_const_array := r22_pe_latency(C_FAMILY, C_XDEVICEFAMILY, C_FAST_BFY, C_FAST_CMPY, 0, C_HAS_NFFT, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_HAS_SCALING, C_HAS_ROUNDING, 1, width_of_pe, mem_type);
    VARIABLE result           : INTEGER         := 0;
  BEGIN
    FOR i IN NUMBER_OF_PEs-PEs_IN_USE TO NUMBER_OF_PEs-1 LOOP
      result                                                                 := result + PE_LATENCIES(i);
    END LOOP;
    RETURN result;
  END get_extra_latency_r22;

  FUNCTION get_output_order_latency_r22(C_FAMILY, C_XDEVICEFAMILY : STRING; C_HAS_NATURAL_OUTPUT, C_OUTPUT_WIDTH, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_HAS_NFFT, C_NFFT_MAX, NFFT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT RAM_OUTPUT_WIDTH : INTEGER := 2*C_OUTPUT_WIDTH;
    CONSTANT HYBRID_REORDER_BUFFER : INTEGER := BOOLEAN'pos(C_USE_HYBRID_RAM = 1 AND r22_allow_reorder_hybrid_ram_use(C_FAMILY, C_XDEVICEFAMILY, C_NFFT_MAX, RAM_OUTPUT_WIDTH, C_REORDER_MEM_TYPE, C_HAS_NATURAL_OUTPUT, C_OPTIMIZE_GOAL));
    VARIABLE result : INTEGER;
  BEGIN
    IF C_HAS_NATURAL_OUTPUT = 0 THEN
      IF C_HAS_NFFT = 0 THEN
        result   := -1;
      ELSE
        IF C_NFFT_MAX - NFFT > 1 THEN
          result := 0;
        ELSE
          result := -1;
        END IF;
        result := result + 1 + BOOLEAN'pos(C_HAS_NFFT = 1 AND ((C_NFFT_MAX-2) > 8));
      END IF;
    ELSE
      result     := INTEGER(2**(NFFT));
      result := result + get_min_mem_delay(C_FAMILY, C_XDEVICEFAMILY, C_REORDER_MEM_TYPE, C_NFFT_MAX, C_OPTIMIZE_GOAL, HYBRID_REORDER_BUFFER);
      IF C_HAS_NFFT = 1 THEN
        result := result + 2 + BOOLEAN'pos(C_HAS_NFFT = 1 AND ((C_NFFT_MAX-2) > 8));
      END IF;
      IF C_HAS_NFFT = 1 AND C_NFFT_MAX - NFFT > 1 THEN
        result := result + 1;
      END IF;
    END IF;
    RETURN result;
  END get_output_order_latency_r22;

  FUNCTION get_fast_bfy_latency_r22(C_NFFT_MAX, C_HAS_NFFT, C_FAST_BFY, NFFT : INTEGER) RETURN INTEGER IS
    VARIABLE result : INTEGER;
  BEGIN
    IF C_FAST_BFY = 1 AND C_HAS_NFFT = 1 AND (C_NFFT_MAX - NFFT) MOD 2 = 0 THEN
      result := -1;
    ELSE
      result := 0;
    END IF;
    RETURN result;
  END get_fast_bfy_latency_r22;

  FUNCTION get_extra_latency_so(C_FAMILY, C_XDEVICEFAMILY : STRING; C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT PE_LATENCY_ACTUAL : INTEGER := so_pe_latency(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);

    CONSTANT PE_LATENCY        : INTEGER := PE_LATENCY_ACTUAL + 1;
    CONSTANT NFFT_MIN          : INTEGER := get_nfft_min(4, C_HAS_NFFT, C_NFFT_MAX);
    CONSTANT NFFT_MIN_REUSE    : INTEGER := so_data_reuse(NFFT_MIN);
    CONSTANT BFP_SCALE_LATENCY : INTEGER := so_bfp_scale_gen_latency(C_HAS_SCALING, C_HAS_ROUNDING) * C_HAS_BFP;
    CONSTANT MAX_REUSE_WAIT    : INTEGER := max_i(PE_LATENCY-NFFT_MIN_REUSE, 0);
    CONSTANT MAX_WAIT          : INTEGER := max_i(MAX_REUSE_WAIT, BFP_SCALE_LATENCY);
    CONSTANT MAX_WAIT_ADJUST   : INTEGER := BOOLEAN'pos(PE_LATENCY_ACTUAL = NFFT_MIN_REUSE);
  BEGIN
    RETURN MAX_WAIT + MAX_WAIT_ADJUST;
  END get_extra_latency_so;


  FUNCTION get_output_order_latency_so(C_FAMILY, C_XDEVICEFAMILY : STRING; C_HAS_NATURAL_OUTPUT, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT SO_RUN_ADDR_GEN_LATENCY : INTEGER := 4;
    CONSTANT XN_RE_DELAY             : INTEGER := 3;
    VARIABLE result                  : INTEGER;
  BEGIN
    result   := SO_RUN_ADDR_GEN_LATENCY;
    IF C_HAS_NATURAL_OUTPUT = 1 THEN
      result := result + XN_RE_DELAY;
    ELSE
      result := result + get_unload_delay(C_FAMILY, C_XDEVICEFAMILY, 4, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
    END IF;
    RETURN result;
  END get_output_order_latency_so;


  FUNCTION get_run_latency(C_FAMILY, C_XDEVICEFAMILY : STRING; NFFT, C_ARCH, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_INPUT_WIDTH, C_HAS_NATURAL_OUTPUT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    VARIABLE result : INTEGER;

  BEGIN

    CASE C_ARCH IS
      WHEN 1 =>
        result := (NFFT+1)/2 * INTEGER(2**(NFFT-2));
        result := result + (NFFT+1)/2 * get_extra_latency_r4(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);

      WHEN 2 =>
        result := NFFT * INTEGER(2**(NFFT-1));
        result := result + NFFT * get_extra_latency_r2(C_FAMILY, C_XDEVICEFAMILY, C_TWIDDLE_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_FAST_CMPY, C_FAST_BFY, C_HAS_SCALING, C_HAS_ROUNDING, C_DATA_MEM_TYPE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);

      WHEN 3 =>
        result := INTEGER(2**(NFFT-1));
        result := result + get_extra_latency_r22(C_FAMILY, C_XDEVICEFAMILY, NFFT, C_NFFT_MAX, C_BRAM_STAGES, C_HAS_SCALING, C_INPUT_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_TWIDDLE_WIDTH, C_HAS_ROUNDING);
        result := result + get_output_order_latency_r22(C_FAMILY, C_XDEVICEFAMILY, C_HAS_NATURAL_OUTPUT, C_OUTPUT_WIDTH, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_HAS_NFFT, C_NFFT_MAX, NFFT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
        result := result + get_fast_bfy_latency_r22(C_NFFT_MAX, C_HAS_NFFT, C_FAST_BFY, NFFT);

      WHEN 4 =>
        result := NFFT * INTEGER(2**NFFT);
        result := result + (NFFT-1) * get_extra_latency_so(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
        result := result + so_pe_latency(C_FAMILY, C_XDEVICEFAMILY, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_FAST_BFY, C_FAST_CMPY, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
        result := result + get_output_order_latency_so(C_FAMILY, C_XDEVICEFAMILY, C_HAS_NATURAL_OUTPUT, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, C_TWIDDLE_WIDTH, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM);
      WHEN OTHERS =>
        ASSERT FALSE REPORT "timing_model : get_run_latency : unknown value of C_ARCH" SEVERITY ERROR;
    END CASE;
    RETURN result;
  END get_run_latency;


  FUNCTION gui_get_transform_latency(C_FAMILY, C_XDEVICEFAMILY : STRING; nfft, C_NFFT_MAX, C_ARCH, C_HAS_NFFT, C_INPUT_WIDTH, C_TWIDDLE_WIDTH, C_OUTPUT_WIDTH, C_HAS_SCALING, C_HAS_BFP, C_HAS_ROUNDING, C_HAS_NATURAL_OUTPUT, C_DATA_MEM_TYPE, C_TWIDDLE_MEM_TYPE, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_FAST_CMPY, C_OPTIMIZE, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM : INTEGER) RETURN INTEGER IS
    CONSTANT NFFT_MIN      : INTEGER         := get_nfft_min(C_ARCH, C_HAS_NFFT, C_NFFT_MAX);
    CONSTANT TW_EXPAND_WIDTH : INTEGER := C_TWIDDLE_WIDTH + 1;
    CONSTANT R_USE_HYBRID_RAM : INTEGER := BOOLEAN'pos(resolve_hybrid_ram_use(C_FAMILY, C_XDEVICEFAMILY, C_ARCH, C_NFFT_MAX, C_DATA_MEM_TYPE, C_OUTPUT_WIDTH, C_BRAM_STAGES, C_HAS_SCALING, C_INPUT_WIDTH, C_REORDER_MEM_TYPE, C_HAS_NATURAL_OUTPUT, C_OPTIMIZE_GOAL, C_USE_HYBRID_RAM));
    VARIABLE cycles : INTEGER := 0;
  BEGIN

    IF  nfft < NFFT_MIN OR nfft > C_NFFT_MAX THEN
      RETURN 0;
    END if;

    IF C_ARCH = 3 THEN
      cycles := INTEGER(2**nfft) / 2 + 3 + 1;
    ELSE
      cycles := INTEGER(2**nfft);
    END IF;
    cycles   := cycles + get_run_latency(C_FAMILY, C_XDEVICEFAMILY, nfft, C_ARCH, C_DATA_MEM_TYPE, C_HAS_ROUNDING, C_HAS_SCALING, C_NFFT_MAX, C_OUTPUT_WIDTH, C_TWIDDLE_MEM_TYPE, TW_EXPAND_WIDTH, C_OPTIMIZE, C_FAST_CMPY, C_HAS_NFFT, C_HAS_BFP, C_BRAM_STAGES, C_REORDER_MEM_TYPE, C_INPUT_WIDTH, C_HAS_NATURAL_OUTPUT, C_OPTIMIZE_GOAL, R_USE_HYBRID_RAM);
    cycles := cycles + INTEGER(2**nfft) + get_unload_delay(C_FAMILY, C_XDEVICEFAMILY, C_ARCH, C_DATA_MEM_TYPE, C_NFFT_MAX, C_TWIDDLE_MEM_TYPE, TW_EXPAND_WIDTH, C_OPTIMIZE_GOAL, R_USE_HYBRID_RAM);

    RETURN cycles;

  END gui_get_transform_latency;


END timing_pkg;
